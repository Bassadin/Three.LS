{
  "version": 3,
  "sources": ["/home/runner/work/Three.LS/Three.LS/src/Turtle.ts"],
  "sourcesContent": ["import { BoxGeometry, Color, Mesh, MeshLambertMaterial, Quaternion, Vector3 } from 'three';\nimport Utils from './Utils';\nexport default class Turtle {\n    //\n    private instructionString: string;\n    private stepLength: number;\n    private rotationStepSize: number; //In radians\n\n    //Rotation\n    private currentRotation: Quaternion = new Quaternion();\n    private rotationSaveStateArray: Quaternion[] = [];\n\n    //MeshToAddTo\n    private meshToAddToSaveStateArray: Mesh[] = [];\n\n    //Position\n    private currentPosition: Vector3 = new Vector3(0, -5, 0);\n    private positionSaveStateArray: Vector3[] = [];\n\n    //Color\n    private colorOne: number[];\n    private colorTwo: number[];\n\n    private boxScale: number;\n\n    private useRandomization = false;\n    private randomizationDeviation = 0.25;\n\n    //Indices of the objects that define a point where a savestate was made, e.g. a 'branching point'\n    public branchingIds: Set<string> = new Set();\n\n    constructor(\n        instructionString: string,\n        stepLength: number,\n        rotationStepSize: number,\n        colorOne: number[],\n        colorTwo: number[],\n        boxScale = 0.2,\n        useRandomization = false,\n    ) {\n        this.instructionString = instructionString;\n        this.stepLength = stepLength;\n        this.rotationStepSize = rotationStepSize;\n        this.boxScale = boxScale;\n        this.useRandomization = useRandomization;\n        this.colorOne = colorOne;\n        this.colorTwo = colorTwo;\n    }\n\n    private saveState(): void {\n        this.positionSaveStateArray.push(this.currentPosition.clone());\n        this.rotationSaveStateArray.push(this.currentRotation.clone());\n    }\n\n    private loadState(): void {\n        if (this.positionSaveStateArray.length == 0) {\n            throw new Error('Cannot load state before it has been written at least once');\n        }\n        this.currentPosition = this.positionSaveStateArray.pop();\n        this.currentRotation = this.rotationSaveStateArray.pop();\n    }\n\n    public getBranchUUIDs(): Set<string> {\n        return this.branchingIds;\n    }\n\n    public generateMeshObject(): Mesh {\n        console.time('Geometry creation');\n\n        const leafCenterPositions: Vector3[] = [];\n\n        // const material: Material = new MeshBasicMaterial();\n        // const boxScale = 0.2;\n        const geometry: BoxGeometry = new BoxGeometry(this.boxScale, this.boxScale, this.boxScale);\n        // const mergedGeometry = new THREE.Geometry();\n        let meshToAddTo: Mesh = null;\n\n        const generatedMesh: Mesh = new Mesh();\n        generatedMesh.castShadow = true;\n        generatedMesh.receiveShadow = true;\n\n        for (let i = 0; i < this.instructionString.length; i++) {\n            switch (this.instructionString.charAt(i)) {\n                case 'F': //Move and draw line in current direction\n                    const currentPositionBeforeMove = this.currentPosition.clone();\n\n                    // console.log(this.colorOne, this.colorTwo)\n\n                    const leafColor: Color = new Color(\n                        this.colorOne[0] +\n                            i * ((this.colorTwo[0] - this.colorOne[0]) / this.instructionString.length) +\n                            (Math.random() * (0.1 - 0.05) + 0.05),\n                        this.colorOne[1] +\n                            i * ((this.colorTwo[1] - this.colorOne[1]) / this.instructionString.length) +\n                            (Math.random() * (0.2 - 0.05) + 0.05),\n                        this.colorOne[2] +\n                            i * ((this.colorTwo[2] - this.colorOne[2]) / this.instructionString.length) +\n                            (Math.random() * (0.1 - 0.05) + 0.05),\n                    );\n\n                    const material: MeshLambertMaterial = new MeshLambertMaterial({ color: leafColor });\n\n                    this.move();\n                    const currentPositionAfterMove = this.currentPosition.clone();\n\n                    const centerPositionBetweenMovePoints: Vector3 = currentPositionAfterMove\n                        .clone()\n                        .lerp(currentPositionBeforeMove.clone(), 2);\n\n                    leafCenterPositions.push(\n                        currentPositionAfterMove.clone().sub(currentPositionBeforeMove.clone()).divideScalar(2),\n                    );\n\n                    const boxMesh = new Mesh(geometry, material);\n                    boxMesh.castShadow = true;\n                    boxMesh.receiveShadow = true;\n\n                    if (meshToAddTo) {\n                        boxMesh.position.copy(centerPositionBetweenMovePoints);\n                        meshToAddTo.attach(boxMesh);\n                    } else {\n                        generatedMesh.attach(boxMesh);\n                    }\n\n                    meshToAddTo = boxMesh;\n\n                    break;\n                case 'G': //Move in current direction\n                    this.move();\n                    break;\n                case '[':\n                    this.saveState();\n                    generatedMesh.attach(meshToAddTo);\n                    this.meshToAddToSaveStateArray.push(meshToAddTo);\n                    this.branchingIds.add(meshToAddTo.uuid);\n                    break;\n                case ']':\n                    this.loadState();\n                    meshToAddTo = this.meshToAddToSaveStateArray.pop();\n                    break;\n                case '+':\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(0, 0, 1));\n                    break;\n                case '-':\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(0, 0, -1));\n                    break;\n                case '&':\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(0, 1, 0));\n                    break;\n                case '\u2227': //Achtung, \u2227 (mathematisches UND) und nicht ^ :D\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(0, -1, 0));\n                    break;\n                case '\\\\':\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(1, 0, 0));\n                    break;\n                case '/':\n                    this.rotateByAxisVectorWithRotationStepSize(new Vector3(-1, 0, 0));\n                    break;\n                case '|':\n                    this.currentRotation.multiply(new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI));\n                    break;\n                default:\n                    console.log('Unknown axiom character: ' + this.instructionString.charAt(i));\n                    break;\n            }\n        }\n\n        let globalCenterPoint: Vector3 = new Vector3();\n        leafCenterPositions.forEach((eachVector3: Vector3) => {\n            globalCenterPoint.add(eachVector3);\n        });\n        globalCenterPoint = globalCenterPoint.divideScalar(leafCenterPositions.length);\n\n        console.timeEnd('Geometry creation');\n\n        return generatedMesh;\n    }\n\n    private move(): void {\n        const randomizationFactor = this.useRandomization\n            ? Utils.RandomRange(1 - this.randomizationDeviation, 1 + this.randomizationDeviation)\n            : 1;\n\n        const absoluteMovement: Vector3 = new Vector3(0, 1, 0)\n            .applyQuaternion(this.currentRotation.clone())\n            .multiplyScalar(this.stepLength * randomizationFactor);\n\n        this.currentPosition.add(absoluteMovement);\n    }\n\n    private rotateByAxisVectorWithRotationStepSize(rotationAxisVector: Vector3): void {\n        const randomizationFactor = this.useRandomization\n            ? Utils.RandomRange(1 - this.randomizationDeviation, 1 + this.randomizationDeviation)\n            : 1;\n\n        this.currentRotation.multiply(\n            new Quaternion().setFromAxisAngle(rotationAxisVector, this.rotationStepSize * randomizationFactor),\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
