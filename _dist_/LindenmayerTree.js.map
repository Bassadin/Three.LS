{
  "version": 3,
  "sources": ["/home/runner/work/Three.LS/Three.LS/src/LindenmayerTree.ts"],
  "sourcesContent": ["import { Euler, Mesh, Object3D, Scene, Clock, Vector3 } from 'three';\nimport Utils from './Utils';\n\nexport default class LindenmayerTree extends Object3D {\n    private mesh: Mesh;\n    private finalScale: number;\n    private scaleSpeed: number;\n    private branchUUIDs: Set<string>;\n    private animationPeriodOffsets: Vector3;\n    private animationPeriodMultiplicators: Vector3;\n\n    constructor(treeMesh: Mesh, finalScale: number, branchUUIDs: Set<string> = new Set<string>()) {\n        super();\n        this.mesh = treeMesh;\n        this.mesh.castShadow = true;\n        this.mesh.receiveShadow = true;\n        this.add(treeMesh);\n        this.finalScale = finalScale;\n\n        this.mesh.scale.set(0, 0, 0);\n\n        this.scaleSpeed = this.finalScale * Utils.RandomRange(0.2, 0.7);\n\n        this.branchUUIDs = branchUUIDs;\n\n        this.animationPeriodOffsets = new Vector3(\n            Utils.RandomRange(-Math.PI, Math.PI),\n            Utils.RandomRange(-Math.PI, Math.PI),\n            Utils.RandomRange(-Math.PI, Math.PI),\n        );\n\n        this.animationPeriodMultiplicators = new Vector3(\n            Utils.RandomRange(0.8, 1.2),\n            Utils.RandomRange(0.4, 0.7),\n            Utils.RandomRange(0.5, 1),\n        );\n    }\n\n    public render(deltaTime: number, sceneClock: Clock): void {\n        if (this.mesh.scale.x < this.finalScale) {\n            this.mesh.scale.addScalar(this.scaleSpeed * deltaTime);\n        } else {\n            this.mesh.scale.set(this.finalScale, this.finalScale, this.finalScale);\n        }\n\n        const elapsedSceneTime = sceneClock.getElapsedTime();\n\n        this.branchUUIDs.forEach((element) => {\n            const obj: THREE.Object3D = this.mesh.getObjectByProperty('uuid', element);\n            if (obj) {\n                obj.rotation.copy(this.getEulerRotationForElapsedTime(elapsedSceneTime));\n            } else {\n                console.log(`object with uuid ${element} not found`);\n            }\n        });\n    }\n\n    private getEulerRotationForElapsedTime(elapsedTime: number) {\n        return new Euler(\n            Math.sin(elapsedTime * this.animationPeriodMultiplicators.x + this.animationPeriodOffsets.x) * 0.02 - 0.01,\n            Math.sin(elapsedTime * this.animationPeriodMultiplicators.y + this.animationPeriodOffsets.y) * 0.12 - 0.06,\n            Math.sin(elapsedTime * this.animationPeriodMultiplicators.z + this.animationPeriodOffsets.z) * 0.02 - 0.01,\n            'XYZ',\n        );\n    }\n}\n"],
  "mappings": "AAAA;AACA;AAEA,6CAA6C,SAAS;AAAA,EAQlD,YAAY,UAAgB,YAAoB,cAA2B,IAAI,OAAe;AAC1F;AACA,SAAK,OAAO;AACZ,SAAK,KAAK,aAAa;AACvB,SAAK,KAAK,gBAAgB;AAC1B,SAAK,IAAI;AACT,SAAK,aAAa;AAElB,SAAK,KAAK,MAAM,IAAI,GAAG,GAAG;AAE1B,SAAK,aAAa,KAAK,aAAa,MAAM,YAAY,KAAK;AAE3D,SAAK,cAAc;AAEnB,SAAK,yBAAyB,IAAI,QAC9B,MAAM,YAAY,CAAC,KAAK,IAAI,KAAK,KACjC,MAAM,YAAY,CAAC,KAAK,IAAI,KAAK,KACjC,MAAM,YAAY,CAAC,KAAK,IAAI,KAAK;AAGrC,SAAK,gCAAgC,IAAI,QACrC,MAAM,YAAY,KAAK,MACvB,MAAM,YAAY,KAAK,MACvB,MAAM,YAAY,KAAK;AAAA;AAAA,EAIxB,OAAO,WAAmB,YAAyB;AACtD,QAAI,KAAK,KAAK,MAAM,IAAI,KAAK,YAAY;AACrC,WAAK,KAAK,MAAM,UAAU,KAAK,aAAa;AAAA,WACzC;AACH,WAAK,KAAK,MAAM,IAAI,KAAK,YAAY,KAAK,YAAY,KAAK;AAAA;AAG/D,UAAM,mBAAmB,WAAW;AAEpC,SAAK,YAAY,QAAQ,CAAC,YAAY;AAClC,YAAM,MAAsB,KAAK,KAAK,oBAAoB,QAAQ;AAClE,UAAI,KAAK;AACL,YAAI,SAAS,KAAK,KAAK,+BAA+B;AAAA,aACnD;AACH,gBAAQ,IAAI,oBAAoB;AAAA;AAAA;AAAA;AAAA,EAKpC,+BAA+B,aAAqB;AACxD,WAAO,IAAI,MACP,KAAK,IAAI,cAAc,KAAK,8BAA8B,IAAI,KAAK,uBAAuB,KAAK,OAAO,MACtG,KAAK,IAAI,cAAc,KAAK,8BAA8B,IAAI,KAAK,uBAAuB,KAAK,OAAO,MACtG,KAAK,IAAI,cAAc,KAAK,8BAA8B,IAAI,KAAK,uBAAuB,KAAK,OAAO,MACtG;AAAA;AAAA;",
  "names": []
}
