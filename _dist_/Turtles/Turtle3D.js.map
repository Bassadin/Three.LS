{
  "version": 3,
  "sources": ["/home/runner/work/Three.LS/Three.LS/src/Turtles/Turtle3D.ts"],
  "sourcesContent": ["import { Vector3, Quaternion, Mesh, BoxGeometry, ShaderMaterial, DoubleSide, Color } from 'three';\nimport { BaseTurtle } from './BaseTurtle';\nimport * as FragmentData from '../shaders/testShader/fragment';\nimport * as VertexData from '../shaders/testShader/vertex';\nimport { Utils } from '../Utils';\n\nexport class Turtle3D extends BaseTurtle {\n    public branchingIds: Set<number> = new Set();\n\n    addGeometryToScene(scene: THREE.Scene): void {\n        console.time('Geometry creation');\n\n        const leafCenterPositions: Vector3[] = [];\n\n        // const material: Material = new MeshBasicMaterial();\n        const boxScale = 0.2;\n        const geometry: BoxGeometry = new BoxGeometry(boxScale, boxScale, boxScale);\n\n        let meshToAddTo: Mesh = null;\n\n        for (let i = 0; i < this.instructionString.length; i++) {\n            // const tries: number[] = [];\n            // const bufferGeometry: BufferGeometry = new BufferGeometry();\n            //  const colorsArray: number[] = [];\n\n            switch (this.instructionString.charAt(i)) {\n                case 'F': //Move and draw line in current direction\n                    const currentPositionBeforeMove = this.currentPosition.clone();\n\n                    // this.colorIndex++;\n\n                    this.newColors = [\n                        0.45 +\n                            i * ((0.4 - 0.45) / this.instructionString.length) +\n                            (Math.random() * (0.1 - 0.05) + 0.05),\n                        0.29 +\n                            i * ((0.72 - 0.29) / this.instructionString.length) +\n                            (Math.random() * (0.2 - 0.05) + 0.05),\n                        0.13 +\n                            i * ((0.2 - 0.13) / this.instructionString.length) +\n                            (Math.random() * (0.1 - 0.05) + 0.05),\n                    ];\n\n                    const material: ShaderMaterial = new ShaderMaterial({\n                        uniforms: {\n                            thickness: { value: 1 },\n                            color: { value: new Color(...this.newColors) },\n                            time: { value: 0 },\n                        },\n                        vertexShader: VertexData.data,\n                        fragmentShader: FragmentData.data,\n                        side: DoubleSide,\n                        alphaToCoverage: true,\n                    });\n\n                    this.move();\n                    const currentPositionAfterMove = this.currentPosition.clone();\n\n                    const centerPositionBetweenMovePoints: Vector3 = currentPositionAfterMove\n                        .clone()\n                        .lerp(currentPositionBeforeMove.clone(), 2);\n\n                    leafCenterPositions.push(\n                        currentPositionAfterMove.clone().sub(currentPositionBeforeMove.clone()).divideScalar(2),\n                    );\n\n                    const boxMesh = new Mesh(geometry, material);\n                    // boxMesh.lookAt(currentPositionAfterMove);\n                    if (meshToAddTo) {\n                        // meshToAddTo.lookAt(currentPositionAfterMove);\n                        boxMesh.position.copy(boxMesh.worldToLocal(centerPositionBetweenMovePoints));\n                        meshToAddTo.attach(boxMesh);\n                    } else {\n                        scene.add(boxMesh);\n                    }\n                    meshToAddTo = boxMesh;\n\n                    break;\n                case 'G': //Move in current direction\n                    this.move();\n                    break;\n                case '[':\n                    this.saveState();\n                    this.meshToAddToSaveStateArray.push(meshToAddTo);\n                    this.branchingIds.add(meshToAddTo.id);\n                    break;\n                case ']':\n                    this.loadState();\n                    meshToAddTo = this.meshToAddToSaveStateArray.pop();\n                    break;\n                case '+':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 0, 1), this.rotationStepSize),\n                    );\n                    break;\n                case '-':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), this.rotationStepSize),\n                    );\n                    break;\n                case '&':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '\u2227': //Achtung, \u2227 (mathematisches UND) und nicht ^ :D\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, -1, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '\\\\':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '/':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(-1, 0, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '|':\n                    this.currentRotation.multiply(new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI));\n                    break;\n                default:\n                    console.log('Unknown axiom character: ' + this.instructionString.charAt(i));\n                    break;\n            }\n        }\n\n        let globalCenterPoint: Vector3 = new Vector3();\n        leafCenterPositions.forEach((eachVector3: Vector3) => {\n            globalCenterPoint.add(eachVector3);\n        });\n        globalCenterPoint = globalCenterPoint.divideScalar(leafCenterPositions.length);\n\n        // mesh.applyMatrix4(new Matrix4().makeTranslation(globalCenterPoint.x, globalCenterPoint.y, globalCenterPoint.z));\n\n        console.timeEnd('Geometry creation');\n        scene.add(Utils.createPlane());\n    }\n\n    move(): void {\n        const absoluteMovement: Vector3 = new Vector3(0, 1, 0)\n            .applyQuaternion(this.currentRotation.clone())\n            .multiplyScalar(this.stepLength);\n\n        this.currentPosition.add(absoluteMovement);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
