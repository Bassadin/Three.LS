{
  "version": 3,
  "sources": ["/home/runner/work/Three.LS/Three.LS/src/Turtles/Turtle3D.ts"],
  "sourcesContent": ["import {\n    Vector3,\n    Quaternion,\n    BufferGeometry,\n    Float32BufferAttribute,\n    MeshBasicMaterial,\n    Mesh,\n    BoxGeometry,\n    Material,\n} from 'three';\nimport { BaseTurtle } from './BaseTurtle';\n\nexport class Turtle3D extends BaseTurtle {\n    addGeometryToScene(scene: THREE.Scene): void {\n        console.time('Geometry creation');\n\n        const leafCenterPositions: Vector3[] = [];\n\n        const material: Material = new MeshBasicMaterial();\n        const geometry: BoxGeometry = new BoxGeometry(1, 1, 1);\n\n        for (let i = 0; i < this.instructionString.length; i++) {\n            switch (this.instructionString.charAt(i)) {\n                case 'F': //Move and draw line in current direction\n                    const currentPositionBeforeMove = this.currentPosition.clone();\n                    this.move();\n                    const currentPositionAfterMove = this.currentPosition.clone();\n\n                    const centerPositionBetweenMovePoints: Vector3 = currentPositionAfterMove\n                        .clone()\n                        .lerp(currentPositionBeforeMove.clone(), 2);\n\n                    leafCenterPositions.push(\n                        currentPositionAfterMove.clone().sub(currentPositionBeforeMove.clone()).divideScalar(2),\n                    );\n\n                    const boxMesh = new Mesh(geometry, material);\n\n                    const boxScale = 0.15;\n                    boxMesh.scale.set(boxScale, boxScale, boxScale);\n\n                    boxMesh.position.copy(centerPositionBetweenMovePoints);\n\n                    scene.add(boxMesh);\n                    console.count('Number of meshes');\n\n                    break;\n                case 'G': //Move in current direction\n                    this.move();\n                    break;\n                case '[':\n                    this.saveState();\n                    break;\n                case ']':\n                    this.loadState();\n                    break;\n                case '+':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 0, 1), this.rotationStepSize),\n                    );\n                    break;\n                case '-':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), this.rotationStepSize),\n                    );\n                    break;\n                case '&':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, 1, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '\u2227': //Achtung, \u2227 (mathematisches UND) und nicht ^ :D\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(0, -1, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '\\\\':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '/':\n                    this.currentRotation.multiply(\n                        new Quaternion().setFromAxisAngle(new Vector3(-1, 0, 0), this.rotationStepSize),\n                    );\n                    break;\n                case '|':\n                    this.currentRotation.multiply(new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI));\n                    break;\n                default:\n                    console.log('Unknown axiom character: ' + this.instructionString.charAt(i));\n                    break;\n            }\n        }\n\n        let globalCenterPoint: Vector3 = new Vector3();\n        leafCenterPositions.forEach((eachVector3: Vector3) => {\n            globalCenterPoint.add(eachVector3);\n        });\n        globalCenterPoint = globalCenterPoint.divideScalar(leafCenterPositions.length);\n\n        // mesh.applyMatrix4(new Matrix4().makeTranslation(globalCenterPoint.x, globalCenterPoint.y, globalCenterPoint.z));\n\n        console.timeEnd('Geometry creation');\n        scene.add(createPlane());\n    }\n\n    move(): void {\n        const absoluteMovement: Vector3 = new Vector3(0, 1, 0)\n            .applyQuaternion(this.currentRotation.clone())\n            .multiplyScalar(this.stepLength);\n\n        this.currentPosition.add(absoluteMovement);\n    }\n}\nfunction createPlane(): THREE.Mesh {\n    const bufferGeometry: THREE.BufferGeometry = new BufferGeometry();\n    const newColors = [Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3];\n    const vertices: any[] = [];\n    const tris: number[] = [];\n    vertices[0] = [-5, -5, 2.5];\n    vertices[1] = [5, -5, 2.5];\n    vertices[2] = [5, -5, -2.5];\n    vertices[3] = [-5, -5, -2.5];\n    tris.push(...[...vertices[0], ...vertices[1], ...vertices[2], ...vertices[0], ...vertices[2], ...vertices[3]]);\n    const colorsArray: number[] = [...newColors, ...newColors, ...newColors, ...newColors, ...newColors, ...newColors];\n    bufferGeometry.setAttribute('position', new Float32BufferAttribute(tris, 3));\n\n    // console.log(colorsArray);\n\n    bufferGeometry.setAttribute('color', new Float32BufferAttribute(colorsArray, 3));\n\n    // console.log(bufferGeometry);\n\n    const material = new MeshBasicMaterial({\n        vertexColors: true,\n    });\n\n    const mesh = new Mesh(bufferGeometry, material);\n    return mesh;\n}\n"],
  "mappings": "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",
  "names": []
}
